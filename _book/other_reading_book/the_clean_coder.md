* 有些代码很难测试，是因为设计时就没有考虑如何测试，唯一的解决办法就是要设计易于测试的代码，最好是先写测试，再写要测的代码
* 如果你希望自己的软件灵活可变，那就应该时常修改它！
* 专业开发人员对自己的代码和测试极有把握，他们会极其疯狂随意地做各种修改，他们对待代码，就如同雕塑家对待泥巴那样，对它进行不断的变形与塑造。
* “术业有专攻”是需要投入时间去追求的
* 桑塔亚纳的诅咒：不能铭记过去的人，注定要重蹈覆辙
* 专业开发人员必须精通：
    * 设计模式：能描述GOF书中的全部24种模式，同时还要有POSA书中的多数模式的实战经验
    * 设计原则：了解SOLID原则，而且要深刻理解组件设计原则
    * 方法：理解XP、Scrum、精益、看板、瀑布、结构化分析及结构化设计等
    * 实践：掌握测试驱动开发、面向对象设计、结构化编程、持续集成和结对编程
    * 工件：了解如何使用UML图、DFD图、结构图、Petri网络图、状态迁移图标、流程图、决策表
* 读书、看相关文章、关注博客和微博、参加技术大会、访问用户群、多参与读书与学习小组，不懂就学，不要畏难。
* 卡塔的形式往往是一个有待解决的简单编程问题，比如编写计算拆分某个整数的素数因子等。练卡塔的目的不是找出解决方法（你已经知道方法了），而是训练你的手指和大脑。每天我都会练一两个卡塔，时间往往安排在正式投入工作之前。
* 专业人士敢于说明真相而不屈从于权势，专业人士有勇气对他们的经理说“不”。优秀的经理人对于敢于说“不”的人，总是求贤若渴。因为只有敢于说“不”，才能真正做成一些事情。你的经理指望的是，你能像他那样竭尽所能地捍卫自己的目标，这样你们两才能得到可能的最好结果。
* 面对艰难决定。直面不同角色的冲突是最好的办法。
* 没有冲突则表明双方均未尝试寻求可接受的共同目标。
* “为什么”远不如“事实”重要，解释“为什么”来让对方接受事实，前提是对方恰好有与你相同的技术背景和好脾气去倾听理解，这些解释也许会有用，但是有时候会招致更多的微观管理。
* 在前提条件相同的情况下，在专业人士这里没有“试试看”这回事，除非条件变更。即付出额外的代价。许诺“尝试”，就意味着你承认自己之前未尽全力，承认自己还有余力可施；就意味着只要你再加把劲还是可以达成目标的，而且，这也是一种表示你将再接再厉去实现目标的承诺，因此，只要你许诺自己会去“尝试”，你其实是在承诺你会确保成功。这样，压力就要由你自己来扛了。如果你的“尝试”没有达成预期的结果，那就表示你失败了。如果承诺尝试，你其实也在承诺将改变自己原来的方案，你是在承认原来的方案中存在不足。如果承诺尝试，你其实是在告诉他们，你有新的方案，新的方案是什么？你将对自己的行为做出哪些改变？你说你在“尝试”，那么你的做法将会有何不同？如果你即没有新方案，又不准备改变自己的行为，如果事事仍然都按你承诺“尝试”之前的方法去做，那么，所谓的“尝试”指的又是什么呢？如果你此前并未有所保留，如果你没有新方案，如果你不会改变你的行为，如果你对自己原先的估计有充分的自信，那么，从本质上讲，承诺“尝试”就是一种不诚实的表现。你在说谎！你这么做的原因，可能是为了护住面子和避免冲突。
* 专业人士常常会成为英雄人物，但这样的荣誉并非是他们所刻意追求的，他们之所以成为英雄人物，是因为他们出色地完成了任务，不但按时，而且符合预算。
* 成为英雄及“解决问题”的诱惑诚然巨大，只是我们要明白，牺牲专业原则以求全，并非问题的解决之道，舍弃这些原则，只会制造出更多的麻烦。所以有一句话叫做：不要用战术上的勤奋去掩盖战略上的懒惰。
* 做出承诺，包含三个步骤：
    * 口头上说自己将会去做
    * 心里认真对待做出的承诺
    * 真正付诸行动
* “缺乏承诺”的征兆：
    * 说话的人显得事情不在“我”的掌控范围内
    * 不愿意承担个人责任
    * 表现的仿佛自己是某种情势的“受害者”，而不是掌控者
* 真正的承诺：你对自己将会做某件事做了清晰的事实陈述，而且还明确说明了完成期限。
* 之所以没成功是因为：
    * 你只能承诺自己能完全掌控的事。如果最终目标依赖于他人，那么你就应该采取些具体行动，接近最终目标
    * 你不太确信是否真能完成得了。即使目标无法完成，你仍能全力前进，离目标更近些。而弄清楚目标能否达成这件事，便是你可以采取的努力行动之一。
    * 有时候你真的无能为力。有些事情先前你可能没预料到，这很现实。但如果你仍然希望自己能够不负众望，那就赶紧去调整别人对你的预期，越快越好。用另一个承诺来代替先前的承诺。如果你不尽早告诉他人可能的问题，就错失了让他们帮助你达成目标，兑现承诺的机会。
* 作为专业的开发人员，已经承诺会遵循和捍卫诸如代码必须经过测试，代码必须要有对应的测试代码，要确保代码清晰整洁，而且必须确保没有影响到系统的其他部分等标准。那在做出其他的任何承诺，都应该和这份承诺保持一致。
* 专业人士对自己的能力极限了如指掌，他们非常清楚自己还能保持效率加班多长时间，也非常明白要付出的代价。
* 专业人士不需要对所有请求都回答“是”，不过，他们应该努力寻找创新的方法，尽可能做到有求必应。当专业人士给出肯定回答时，他们会使用正式的承诺，以确保各方能明白无误地理解承诺的内容。
* 具备“出错感知能力”：能够感知到错误确实非常重要，不只对“录入”是这样，对于一切事情莫不如此，说明你已经能够非常迅速地获得反馈，能够更为快速地从错误中学习。
* 在编码时你必须平衡互相牵制的多种因素：
    * 代码必须能够正常工作。必须理解当前要解决的是什么问题以及该如何解决。必须确保编写的代码忠实遵循解决方案。必须管理好解决方案的每一处细节，并且使语言、平台、现有架构以及当前系统的所有问题和平共处。
    * 代码必须能够帮你解决客户提出的问题。很多时候，客户提出的需求其实并没能真正解决他们自己的问题。这有赖于你去发现这些问题并与客户交流，以确保代码能够满足客户的真实需求。
    * 代码必须要能和现有系统结合的天衣无缝。你的代码不能让系统变得更僵硬、更脆弱、更晦涩，必须要妥善管理好各种依赖关系。简而言之，编写代码时必须遵循稳健的工程原则。
    * 其他程序员必须能读懂你的代码。这不仅包括要写好注释这类事，还包括要精心锤炼代码。使它能够表达你的编程意图。要做到这点很不容易。事实上，这可能是程序员最难精通的一件事。
* 如果感到疲劳或者心烦意乱，千万不要编码。强而为之，最终只能再回头返工。相反，要找到一种方法来消除干扰，让心绪平静下来。
* 疲劳的时候，千万不要写代码。奉献精神和职业素养，更多意义上指要遵循纪律原则而非成为长时间工作的工作狂。要确保自己已经将睡眠、健康和生活方式调整到最佳状况，这样才能做到在每天的8小时工作时间内全力以赴。
* “流态区”：这是程序员在编写代码时会进入的一种意识高度专注但思维视野却会收拢到狭窄的状态。在这种状态下，他们会感到效率极高，会感到“绝无错误”。因此他们一直苦苦追求进入这种状态，并经常以能在那种状态下维持多久来衡量自我价值。这其实只是一种“浅层冥想”状态，在这种状态下，为了追求所谓的速度，理性思考的能力会下降。在流态区，你其实放弃了顾及全局，因此，你很可能会做出一些后来不得不推倒重来的决策。在流态区写代码可能会快些，但是后面你将不得不更多地回头重新审视这些代码。
* “创造性输出”依赖于“创造性输入”
* 测试时间和编码时间是一样昂贵的，采用“测试驱动开发”能够显著降低调试时间。衡量你是否是一名专业人士的一个重要方面，便是看你是否能将调试时间尽量降到最低。绝对的零调试时间是一个理想化的目标，无法达到，但要将之作为努力方向。
* 软件开发是一场马拉松，而不是短跑冲刺，你无法全程一直以最快的速度冲刺来赢得比赛，只有通过保存体力和维持稳定节奏来取胜。无论是赛前还是赛中，马拉松选手都会仔细调整好自己的身体状态。专业程序员同样也要仔细地保存好自己的精力和创造力。
* 有时候可能会由于和问题贴的太近，无法看清楚所有的可选项，由于大脑中富有创造性的部分被紧张的专注力所抑制，你会错过很棒的解决方案。
* 要根据目标定期衡量进度，使用三个考虑到多种因素的期限：乐观预估 | 标称预估 | 悲观预估。尽量严守这三个时间点，不要把预估和期望值混淆在一起！把这三个数字呈现给团队和利益相关者，并每天修正这些数字。
* 坚持维持你的估算！你最初的估算比你在老板在面前时做出的任何调整估算都要准确的多。告诉老板你已经考虑过所有情况（因为你确实已经这么做了），唯一能够加快进度的方法就是缩减范围。不要经受不住诱惑盲目冲刺。
* 不应该采用额外加班加点工作的方案：除非以下三个条件都能满足
    * 你个人能挤出这些时间
    * 短期加班，最多加班两周
    * 你的老板要有后备预案，以防万一加班措施失败了
* 如果连所有代码是否都可以正常运行都不知道，还算什么专业人士？如果每次修改代码后没有测试，如何能够知道所有代码可以正常运行？如果缺乏极高覆盖率的自动化单元测试，如何能够做到每次修改代码后都对代码进行测试？如果不采用TDD，如何能够获得极高覆盖率的自动化单元测试？
* TDD三项法则：
    * 在编好失败单元测试之前，不要编写任何的产品代码。
    * 只要有一个单元测试失败了，就不要再写测试代码，无法通过编译也是一种失败情况。
    * 产品代码恰好能够让当前失败的单元测试成功通过即可，不要多写。
* 单元测试即是文档，它们描述了系统设计的最底层的设计细节，它们清晰准确，以读者能够理解的语言写成，并且形式规整可以运行。它们事最好的底层文档。
* 测试代码的一个问题是必须隔离出待测试的代码。如果一个函数调用了其他函数，单独测试它通常会比较困难。为了编写测试，你必须找出将这个函数和其他函数解耦的办法。换言之，测试现行的需要，会迫使你去考虑什么是好的设计。如果不先写测试，就可能出现各个函数耦合在一起最终变成无法测试的一大团的问题，如果后面再写测试，你也许能够测试整个大块的输入和输出，但是很难测试单个函数。
* 事后写的测试只是一种防守，而先行编写的测试则是进攻，事后编写测试的作者已经受制于已有代码，他已经知道问题是如何解决的，与采用测试先行的方式编写的测试代码比起来，后写的测试在深度和捕获错误的灵敏度方面要逊色很多。
* 练习卡塔的目的在于，在需要的时候，可以凭借本能完美出招。
* 编程卡塔也是一整套敲击键盘和鼠标的动作，用来模拟编程问题的解决过程，练习者不是在解决真正的问题，因为你已经之道了解决方案。相反，你是在练习解决这个问题所需要的动作和决策。反复的练习会训练大脑和手指如何动作和反应，在不断练习当中，你或许会发现动作的细微进步，或者解决问题效率的小幅提升。更重要的是，它特别有利于在潜意识中构筑通用的问题与解决方案间的联系，以后在实际编程中遇到这类问题，你马上就知道要如何解决。
* 瓦萨：两个人的卡塔
* 专业开发人员知道，评估可以而且必须基于不那么精确的需求，这些评估只是评估而已。为了强调这点，职业开发人员通常会在评估中使用误差棒，这样业务方就能理解不确定性
* 需求文档中的每一点模糊之处，都对应着业务方的一点分歧。当然，模糊不只来自于分歧或争论。有时候，业务方会想当然地认为看文档的人懂得自己的意思。
* 验收测试：业务方与开发方合作编写的测试，目的在于确定需求已经完成。
* 完成：所有的代码都写完了，所有的测试都通过了，QA和需求方已经认可
* 单元测试：程序员写给程序员的，是正式的设计文档，描述了底层结构及代码行为。深入系统内部进行，调用特定类的方法，覆盖大多数的异常路径。关心单测结果的是程序员而不是业务人员。
* 验收测试：是业务方写给业务方的，是正式的需求文档，描述了业务方认为系统应该如何运行。在系统外部，通常是在API或者是UI级别进行。关心验收测试结果的是业务方和程序员
* 集成测试：只对那些组件很多的较大型系统才有意义，将组件装配成组，测试它们之间是否能正常通信，并不会测试业务规则，一般由系统架构师或主设计师来编写，用以确认系统架构层面的结构是否正确无误。在这个层次上，也许已经可以进行性能测试和吞吐率测试了。多使用与组件测试同样的语言和环境来编写，一般不会作为持续集成的一部分，因为集成测试的运行时间通常都比较长。
* 系统测试：是针对整个集成完毕的系统来运行的自动化测试，是最终的集成测试，不会直接测试业务规则，而是测试系统是否已正确组装完毕，以及系统各个组成部件之间是否能正确交互，应该包含吞吐率测试和性能测试。由系统架构师和技术负责人来编写。目的不是要确保正确的系统行为，而是要确保正确的系统构造。
* 人工探索式测试：需要人工介入、敲击键盘、盯牢屏幕的测试。不是要证明每条业务规则、每条运行路径都正确，而是要确保系统在人工操作下表现良好，同时富有创造性地找出尽可能多的“古怪之处”。
* 验收测试的目的是沟通、澄清、精确化。开发方、业务方、测试方对验收测试达成共识，大家都能明白系统的行为将会是怎样。各方都应当记录这种准确的共识。
* 测试的主要目的是如实描述系统的设计、结构、行为是否达到了具体指标，但是其真正的价值不在测试上，而在具体指标上。
* 写测试是为了确定系统的各项指标符合要求。确定这些细节指标的目的，是为了确定系统的指标；只有确定这些细节指标，程序员才能确知“完成”；只有确定这些细节指标，业务方才能确认他们花钱开发的系统确实满足了需求；只有确认这些指标，才可以真正做到自动化测试。
* 业务分析员：测试“正确路径”，以证明功能的业务价值；QA：测试“错误路径“ | 边界条件 | 异常 | 例外情况，因为QA的职责是考虑哪些部分可能出问题。
* 身为专业开发人员，与编写测试的人协商并改进测试是你的职责，绝不能被动接受测试。因为有时候，你刚开始实现某个功能。就会发现有些测试没什么意义。有些太复杂，有些不灵活，有些包含愚蠢的假定，还有些干脆就是错的。
* 测试系统功能时，应当调用真实的API，而不是GUI，要把GUI和业务逻辑分开，因为GUI很容易变化，所以针对GUI的测试很不稳定。
* 整套持续集成系统应该由源代码管理系统来触发。只要有人提交了代码，持续集成系统就会开始构建，并运行所有的测试，测试结果会用电子邮件发送给团队的所有人。
* 保持持续集成系统的时刻运行是非常重要的。持续集成不应该失败，如果失败了，团队里的所有人都应该停下手里的活，看看如何让测试通过。在持续集成系统里，失败的集成应该视为紧急情况，也就是“立刻中止”型事件。
* 要解决开发方和业务方沟通问题，唯一有效的办法就是编写自动化的验收测试，这些测试足够正式，所以其结果有权威性。这些测试不会造成模糊，也不可能与真实系统脱节。它们，就是无可挑剔的需求文档。
* QA在团队中扮演的角色是”需求规约定义者“和”特性描述者“
    * ”需求规约定义者“：QA和业务人员一起创建自动化验收测试，作为系统真正的需求规约文档。每轮迭代中，他们都可以从业务人员那里收集需求，将之翻译为向开发人员描述系统行为的测试。通常，业务人员编写针对正常路径的测试（happy-path test),而由QA编写针对极端情况(corner)、边界状态(boundary)、异常路径(unhappy-path)的测试
    * ”特性描述者“：描述系统运行中的真实情况，将之反馈给开发者和业务员。在这项任务中，QA并没有解析需求，而是在鉴别系统的真实情况
* 好的领导一定会主动维护你拒绝出席会议的决定，因为他和你一样关心你的时间。
* 如果会议让人厌烦，就离席。因为你有责任合理分配老板给你的时间和金钱，所以，选个合适的机会商量如何离席，并非不专业的做法。
* 为了合理使用与会者的时间，会议应当有清晰的议程，确定每个议题所花的时间，以及明确的目标。
* “立会”：每个问题的回答时间不应当超过20S，每个人的发言不超过1min
    * 我昨天干了什么？
    * 我今天打算干什么？
    * 我遇到了什么问题？
* "迭代计划会议“：用来选择在下一轮迭代中实现的开发任务
    * 会前：评估可选择任务的开发时间 + 确定这些任务的业务价值
    * 会中：节奏足够快，简明扼要地讨论各个候选任务，然后决定是选择还是放弃。会议在每个任务上花的时间限制在5-10min。如果需要更详细的讨论，则应当另选时间，挑出团队中的一部分人专门进行。
* “迭代回顾和DEMO展示”：在迭代的末尾召开，团队成员花20min讨论本轮迭代中什么做的对，什么做的不对。花25min来演示最新工作成果的demo。最好放在最后一天下班前45min召开。
* 凡是不能在5min内解决的争论，都不能靠辩论解决，因为各方都拿不出足够有力的证据，所以这类争论依据的不是事实，而是信念。
* 注意力是稀缺资源，它类似魔力点数，如果你用光了自己的注意力点数，必须花一个小时或更多的时间做不需要注意力的事情来补充它。注意力点数也会随时间的流逝而减少，如果不及时使用，它就会消失。学会妥善使用自己的注意力点数，选择在注意力点数充裕的时候编程，在注意力点数匮乏时做其他事情。
* 肌肉注意力有助于改善心智注意力，而且不仅仅是简单的恢复，定期训练肌肉注意力，可以提升心智注意力的上限。
* 预估是业务人员和开发人员之间最主要的障碍，横亘在双方之间的种种不信任，几乎都由它引发。业务方觉得预估就是承诺，开发方认为预估就是猜测，两者相差迥异。专业开发人员能够清楚区分预估和承诺，只有在确切知道可以完成的前提下，他们才会给出承诺。此外，他们也会小心避免给出暗示性承诺。他们会尽可能清楚地说明预估的概率分布，这样主管就可以做出合适的计划。
* PlanningPoker.com | 德尔菲法 | 规划扑克 | 预估任务
* 想象一下灵魂出窍后的体验：你看见自己躺在一张手术台上，一位外科医生给你做开胸手术，医生竭力挽救你的性命，但是时间有限，也就是说，他的一举一动都与病人生死攸关——你命悬一线。你期望医生的表现如何？你希望他冷静、井井有条吗？你希望他清楚准确地吩咐助手吗？你希望他严格遵循当初训练时的做法坚守手术规程吗？还是想让他汗流浃背、咒骂之声不断？想让他乱扔手术器械、把东西摔得哐当响吗？想让他满腹怨气责怪管理人员设定的不现实的手术时间，一直嚷嚷时间不够用吗？你期望他表现得像一名专业人士，还是像我们常见的某些开发人员的那种做派？即使有压力，专业开发人员也会冷静果断。尽管压力不断增大，他仍然会坚守所受的训练和纪律，他知道这些是他赖以战胜由最后期限和承诺所带来的压力感的最好方法。
* 危机中的纪律：选择那些你在危机时刻依然会遵循的纪律原则，并且在所有工作中都遵守这些纪律。遵守这些纪律原则是避免陷入危机的最好途径。当困境降临时，也不要改变行为。如果你遵守的纪律原则是工作的最佳方式，那么即使是在深度危机中，也要坚决秉持这些纪律原则。
* 12人团队：7名程序员 + 2名测试员 + 2名分析师 + 1名项目经理