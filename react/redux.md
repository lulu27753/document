## Redux DevTools 

### 时间旅行

- 将局部state统一到全局store中做状态管理
- 开发环境中安装了与状态管理库配套的 DevTools ，或引入了特殊的监控组件
- 开发环境中启用了webpack的HMR热加载

### 复杂前端应用分类

#### 数据驱动的前端应用

- 业务复杂度：后台无穷无尽的数据和复杂业务流程
- 如购物网站、12306订票平台

#### 事件驱动的前端应用

- 业务复杂度：来自于用户的输入事件
- 如富文本编辑器

### 时间旅行与应用分类

Redux开发工具能支持时间旅行，所以我们的应用在遇到类似需要回溯状态的场景时，上Redux的风险更小

**数据驱动：** 几乎完全不需要时间旅行的能力。由于来自后端的数据才是实质上的Single Source of Truth。在前端基于状态管理工具的回溯操作非常容易破坏这种对数据源的依赖，导致前后端的状态不一致。
Eg: 如果某管理后台应用的表单页支持了时间旅行，那么对表单提交事件的「旅行重放」显然会带来重复的POST请求，而这并不是一个幂等的操作，这时前端的时间旅行甚至会违背RESTful的理念

**事件驱动:** 重度依赖时间旅行类的技术。市面上几乎所有的靠谱富文本编辑器，都维护了自己的一套撤销栈————时间旅行的核心。对这类应用，时间旅行甚至是影响体验的核心因素之一：只要撤销功能实现的好，用户在遇上预期外行为乃至编辑器bug的时候，也能自己撤销回去，然后尝试其他的交互方式来达成目标。

### 时间旅行技术栈的负担

#### 全局状态的反模式

- 尽可能编写无状态组件，它们的状态由全局store管理
- 全局store的数据结构应该尽量扁平

少用全局变量，会出现很多问题
- 命名冲突
- 很难表达嵌套的数据类型:在 Redux 全家桶里更新 `{a: {b: {c: {d: 1 }}}}` 几乎是必须借助辅助工具的,如Immutable | Slate.js
- 不符合经典的计算机体系结构: 

 在 A 组件里实现的方法，触发它的事件在 B 组件里，而 C 组件又需要订阅执行结果…… 这时候纯 React 处理起来确实棘手，但只要将 store 放置在 A、B、C 三个组件中最顶级的一个里——而不需要放置在全局——而后通过 Context 的定制，就足够解决这个问题了。

#### 时间旅行与 Boilerplate

Redux 为了调试体验，牺牲了开发体验

Boilerplate 代码比较多，要发一个简单的请求，都要 Action、Reducer、Middleware 走一波，思维负担比较大

Webpack HMR 和 Redux DevTools 相结合所带来的一个重要能力：一旦你更改了某个 Reducer 的代码，那么所有的 Action 都会重新求值，更新状态。


#### 时间旅行并非开箱即用

在需要时间旅行特性的应用里，Redux除了引入它的一套约定外，帮不上什么忙。对于时间旅行而言，它在数据驱动的应用里基本不需要实现，而在事件驱动的应用里实现时，Redux的帮助也很有限


### 替代方案

#### MobX 与数据驱动应用

基于class的数据模型结构，可以非常轻松地封装每种模型的增删改查操作，并且可以非常方便地实例化多个不同store的实例，注入到所需的组件中，对于store间通信，实例化子store时注入一个到RootStore的引用即可

基于TS的类型声明远比Redux里原始的字符串常量 + 原生JS对象要先进

基于依赖追踪的更新机制能够精确地做到在对象某个属性更新时，按需更新组件。在一般的业务场景下，这比全量更改状态再Diff的操作的性能要更好

Mobx在重绘时的性能优势是以访问劫持后更大的内存占用为代价的

#### RxJS 与事件驱动应用

事件驱动应用，对异步逻辑的把握很重要。

redux-saga提供了一些处理异步副作用的方式，但是RxJS很强大

[响应式编程入门：实现电梯调度模拟器](https://juejin.im/post/59a2d93051882511264e8617)


















## 资源

[从时间旅行的乌托邦，看状态管理的设计误区](https://juejin.im/post/5a37075051882527a13d9418)