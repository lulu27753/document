* 电脑内存是一个巨大的可读写阵列
* 存储在内存中的数据
    * 程序的代码，包括操作系统的代码
    * 所有的变量和程序中用到的数据
* 编译器和操作系统共同工作帮助开发者完成大部分的内存管理
* 垃圾回收: JS会在创建变量（对象、字符串）时自动分配内存，并在这些变量不被使用时自动释放内存.new了一个对象之后，它申请占用了一块堆内存，当把这个对象指针置为null时或者离开作用域导致被销毁，那么这块内存没有人引用它了在JS里面就会被自动垃圾回收
* 内存泄露: 指new了一块内存，但无法被释放或者被垃圾回收.如果new的这个对象指针没有被置为null，且代码里面没办法再获取到这个对象指针了，就会导致无法释放掉它指向的内存，也就是说发生了内存泄露
* 编译代码的时候，编译器会解析原始数据类型，提前计算出它们需要多大的内存空间。然后将所需的数量分配在栈空间中。之所以称为栈空间，是因在函数被调用的时候，他们的内存被添加在现有内存之上（就是会在栈的最上面添加一个栈桢来指向存储函数内部变量的空间）。终止的时候，以LIFO(后进先出)的顺序移除这些调用。
* 当函数调用其他函数的时候，每一个函数被调用的时候都会获得自己的栈块。在自己的栈块里会保存函数内所有的变量，还有一个程序计数器会记录变量执行时所在的位置。当函数执行完之后，会释放它的内存以作他用。
* 根本目标是促进这个生态的持续繁荣，而不是只解决个别的、局部的、短期的问题，这是与其它互联网应用完全不同的地方，比如我们不是要满足用户需求就够了，我们还需要让商家、达人都能快速成长，好的东西能快速浮现出来提供给用户
* 垃圾回收算法：
    * 引用计数垃圾回收：
        * 一个对象在没有其他的引用指向它的时候就被认为“可被回收的”
        * 缺点：“一个对象没有被引用”导致这个对象不能被访问，但是对象不能被访问到，不一定不存在引用
    * 标记清除算法：确定是否可以找到某个对象，2012年起，所有浏览器都内置了标记清除垃圾回收器
        * 垃圾回收器生成一个根列表。根通常是将引用保存在代码中的全局变量。在JS中，window对象是一个可以作为根的全局变量。
        * 所有的根都被检查和标记成活跃的（不是垃圾），所有的子变量也被递归检查。所有可能从根元素到达的都不被认为是垃圾。
        * 所有没有被标记成活跃的内存都被认为是垃圾。垃圾回收器就可以释放内存并且把内存还给操作系统。
* 释放内存的工作由GC来做，将不再使用的对象KILL掉，回收占有的内存。就是将没有被任何变量引用的对象回收。去除对象的所有引用就能让GC回收对象。
* 对于局部变量引用的对象，函数执行完毕，局部变量被销毁，它引用的对象自然没有别的变量引用了，GC会回收。但是涉及到异步回调、事件绑定等匿名函数时则要小心
* 常见的内存泄露：事件绑定，形成了一个闭包，导致一些变量一直存在


























