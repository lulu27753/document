* 只要存在从虚拟DOM到真实DOM的转换器，就可以实现虚拟DOM的最终界面呈现，从而达到跨平台的目的。而从虚拟DOM到真实DOM的转换工具由react-dom实现，从虚拟DOM到移动APP的转换工具由react-native实现。
* 组件：封装起来的具有独立功能的、可复用的UI部件
* 一个组件应该具有的特征
    * 可组合性(Composeable):一个组件可以很方便的与其他组件一起配合使用，或者嵌套在另一个组件的内部。如果一个组件内部创建包含了另一个组件，那么父组件拥有(own)它创建的子组件。通过这个特性，一个复杂的UI组件可以拆分成多个简单的UI组件
    * 可重用性(Reusable)：每个组件都是具有独立功能的单元，它可以不加更改的在多个UI场景重复使用
    * 可维护性(Maintainable):每个小的组件仅仅包含自身的完整逻辑，更容易被理解和维护
* React组件：带有props属性集合和state状态集合并且构造出一个虚拟DOM结构的对象。其核心是render函数，该函数负责该组件虚拟DOM的构建。props属性集合保存组件的初始属性数据；state状态集合保存组件的状态数据；render函数的主要职责是根据state状态，结合props属性，进行虚拟DOM的构建。所有的变化均由状态的变更引发，状态的变更通过调用组件实例的setState(data, callback)完成
* 使用ReactLink也可以将React拓展为双向绑定，但不建议使用
* React并不非常认同MVC开发模式，但可以拓展为MVC架构，如Router和Flux
* React虽然具有服务器端渲染的能力，但其实现只能基于Node.js架构，目前还不能在其它平台上使用
* React
    * react.js:实现React核心的逻辑，且与具体的渲染引擎无关，从而可以跨平台共用。包含了React.createElement | React.createClass等核心API
    * react-dom.js: 包含了具体的DOM渲染更新逻辑，以及服务器端渲染的逻辑。主要API为ReactDOM.render
    * React支持的浏览器有IE8以上版本、Chrome和Firefox
* 通过React.createElement调用产生的元素是“虚拟DOM”，虚拟DOM树由ReactDom.render()渲染到实际的浏览器DOM节点上，形成最终的界面效果
* ReactNode:轻量的、无状态的、不可变的虚拟DOM元素。其数据来源可以是字符串(string)|数字串(number) | ReactElement；同时ReactNode也支持嵌套，可包含ReactNode的数组，多级嵌套的ReactNode最终形成一颗虚拟DOM树
* ReactElement：是ReactNode的主要数据来源，有四个属性：type | props | key | ref
* React内部的渐进式更新机制：
    通常React并不直接操作浏览器DOM，而是操作内部的虚拟DOM。当数据发生改变时，React现在虚拟DOM中自动计算判断出局部对应变更的部分，最后只将变更的部分反应到真实的浏览器DOM中。频繁操作DOM会导致页面反复重画，代价昂贵，同样如果每次更新都是整体虚拟DOM发生变化，那么React快速的优势就不复存在了，但这种整体发生变化是很难发生的，因为这种情况完全可以设计为两个不同的组件了。实际使用中绝大多数变更都是局部变化。
* 虚拟DOM的特殊属性：
    * key:可选的唯一标识符。当组件在渲染过程中被打乱的时候，按照差异检测逻辑，有时候可能会发生组件先被销毁而后又被重新创建的情况，产生不必要的开销。通过给组件绑定一个唯一的key属性，可以避免这样的问题
    * ref:用于访问组件对应的实际DOM元素。在某些情况下，可能会需要直接操作一个组件渲染后所对应的DOM标记，比如要调整DOM元素的绝对位置，或者在大型的非React应用中使用React组件，或者在React中重复使用已有的代码库等。React给出的解决办法是使用ref属性。
    * dangerouslySetInnerHTML:用来直接插入纯HTML文本字符串，避免React的自动转义。例如当我们需要展示从后台取到的含有标签的富文本数据时可使用该属性。
* 前端应该组件化，然而传统的前端组件化思想是基于模版技术的，结构化标记和生成结构化标记的代码是紧密关联的，展现逻辑一般都很复杂，使用模版语言会使展现变得笨重。而React通过JS代码生成HTML和组件树，其理念是组件与关注点分离，可以使用JS丰富的表达力去构建UI。
* JSX语法转译器：当遇到“<"标识符就会启动JSX转译过程，遇到“{"标识符就会当作JS代码处理。元素的标签、属性、子元素都会被当作参数传给React.createElement()
* JSX中的注释：在JSX中使用注释与在JS中使用注释一样，本质上它就是JS的一部分。但是要注意⚠️：当注释作为独立子节点时需要用{}包起来。
* React的设定中，初始化props后，props是不可变的
* React中当需要增加组件的属性时，定义一个展开属性对象，并通过{...extendProps}的方式引入，React会自动将extendProps中的属性复制到组件的props属性中。⚠️：这里的“...“是属性展开的特殊标识，ES6中也使用“...“作为解构赋值中剩余属性标识，但两者没有关系。
* JSX中特殊属性：
    * class属性必须以className代替
    * `<label>`标签的属性for必须用htmlFor代替
* JSX中行内样式：在React中，行内样式style并不是以CSS字符串的形式出现，而是一个特定的带有驼峰命名风格的JS样式对象。这样的设计是为了与DOM中style的JS属性名保持一致，且有助于弥补XSS安全漏洞。在这个样式对象中，key值是用驼峰形式表示的样式名，而其对应的value则是样式值，通常是一个字符串。
* React将界面组件看成一个状态机，用户界面拥有不同状态并根据状态进行渲染输出，用户界面和数据始终保持一致。
* props:
    * 整个组件生命周期中都是只读的，是组件从外界接收静态信息的主要渠道
    * 相对固定的、组件内只读的、应由父组件传递进来的属性适合放在props中，如组件的类名、颜色、字体、事件响应回调函数等
    * this.props.children:数组中会包含本组件实例的所有子组件
    * this.props.context:跨级包含上级组件的数据等
* render():
    * 检测this.props和this.state，再返回一个单一组件实例，也可返回null或false表明不需要渲染任何东西
    * 在这个函数中，不应该修改组件state，不读写DOM信息，也不与浏览器交互。
    * 确实需要与浏览器交互，则应在生命周期函数中设置
    * 其返回的内容是子组件层级树实例在特定时间的一个描述，React会根据这个描述进行差异分析，再生成实际的组件实例
* 实例化阶段：
    * getInitialState():用于对本组件实例的state初始数据，赋予组件实例的默认值
    * componentWillMount()：
    * render()
    * componentDidMount()
